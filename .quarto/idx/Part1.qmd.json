{"title":"Testing ground for bachelor thesis","markdown":{"yaml":{"title":"Testing ground for bachelor thesis","author":"Mélanie Fournier","format":{"html":{"code-fold":true},"pdf":{"geometry":["top=30mm","left=20mm"],"number-sections":true,"include-in-header":{"text":"\\usepackage{amsmath}\n\\usepackage{easy-todo}\n\\usepackage{amsthm}\n"},"documentclass":"article","fontsize":"14"}},"jupyter":"python3"},"headingText":"Explicit RK2 and stability function","containsRefs":false,"markdown":"\n\n\n\n\n```{python}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom testProblemClass import testProblem\n```\n\nWe now have everything we need to get going, let's plot the residual norm over iteration as a first test\n\n```{python}\n#| fig-cap: Evolution of the residual norm over a number of iteration.\n\n#Create the object\nb = 0.5\nn = 100\n\nalpha = 0.13813813813813813\ndeltaT = 3.5143143143143143\nconvDiffProb = testProblem(b,n)\ny, resNormList = convDiffProb.mainSolver2(0.093093,5.6003,20)\n\nx = np.linspace(0,1,n+2) #Create space\nyTh = np.zeros(n+2)\nyTh[1:n+1] = np.linalg.solve(convDiffProb.M,convDiffProb.e)\n\nyApprox = np.zeros(n+2)\nyApprox[1:n+1] = y\nfig, (ax1,ax2) = plt.subplots(1,2)\n\nax1.plot(resNormList)\nax1.set_xlabel(\"Iteration\")\nax1.set_ylabel(\"Residual norm\")\nax1.set_yscale('log')\n\nax2.plot(x,yTh,label = 'Discretised solution')\nax2.plot(x,yApprox,label = \"iterative solution\")\nax2.legend()\n\nfig.show()\n\n\n```\n\n```{python}\nfrom matplotlib import cm\nfrom matplotlib.ticker import LinearLocator\n\ndef resRatio(resNormList):\n    return resNormList[-1] / resNormList[-2]\n\n\n\nl = 100\ndeltaTgrid = np.linspace(0.000001,0.00001,l)\nalphaGrid = np.linspace(0,1,l)\n\ndeltaTgrid, alphaGrid = np.meshgrid(deltaTgrid,alphaGrid)\n\nresRatioGrid2 = np.zeros((l,l))\n\nfor i in range(l):\n    for j in range(l):\n        #print('alpha', alphaGrid[j,0])\n        #print('deltaT', deltaTgrid[0,i])\n        y , resNormList = convDiffProb.mainSolver2(alphaGrid[j,i],deltaTgrid[j,i],10)\n        ratio = resRatio(resNormList)\n        #print('ratio', ratio)\n        resRatioGrid2[j,i] = resRatio(resNormList)\n\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n\n\nclippedRatio = np.clip(resRatioGrid2,0.8,0.9)\nsurf = ax.contour(deltaTgrid,alphaGrid,clippedRatio,levels = [0.8,0.85,0.9])\n\ntransformedContour = np.log(1/(1+np.exp(-clippedRatio+1)))\n\n\n\nprint(np.nanmin(resRatioGrid2))\nprint(np.argmin(resRatioGrid2))\n\n```\nContour plot\n```{python}\nfig, ax = plt.subplots()\ncp = ax.contour(deltaTgrid,alphaGrid,resRatioGrid2,levels = [0.83,0.86,0.88,0.9,1], cmap=cm.coolwarm, linewidth=0)\nax.clabel(cp)\n#ax.view_init(elev = 90,azim = 150)\nplt.show()\n\n\n```\nSurface plot\n```{python}\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\nax.plot_surface(deltaTgrid,alphaGrid,np.clip(resRatioGrid2,0.5,1), cmap=cm.coolwarm, linewidth=0)\nax.view_init(elev = 90,azim = 180)\nplt.show()\n```\n```{python}\n\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n\n# Make data.\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\n# Plot the surface.\nsurf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm,\n                       linewidth=0, antialiased=False)\n\n# Customize the z axis.\nax.set_zlim(-1.01, 1.01)\nax.zaxis.set_major_locator(LinearLocator(10))\n# A StrMethodFormatter is used automatically\nax.zaxis.set_major_formatter('{x:.02f}')\n\n# Add a color bar which maps values to colors.\nfig.colorbar(surf, shrink=0.5, aspect=5)\n\nplt.show()\n```\n\n```{python}\nimport sys\nprint(sys.executable)\n```\n\n```{python}\nimport numpy as np\nimport matplotlib.pyplot as plt\n```\n\n\nNecessary functions go here.\n\n\n```{python}\ndef RK2(f,y,t,deltaT,alpha,**args):\n    \"\"\"Second order family of Rk2\n    c = [0,alpha], bT = [1-1/(2alpha), 1/(2alpha)] , a2,1 = alpha \"\"\"\n    k1 = f(t,y,**args)\n    k2 = f(t + alpha*deltaT, y + alpha*deltaT*k1,**args)\n    yNext = y + deltaT*(k1*(1-1/(2*alpha)) + k2 * 1/(2*alpha))\n    return yNext\n    \ndef buildM(b,n):\n    \"\"\"\n    we go from u0 to u(n+1).\n    \"\"\"\n    deltaX = 1 / (n+1)\n    A = 1/deltaX *(np.eye(n) -1 * np.eye(n,k = -1))\n    B = b/deltaX**2 * (-2*np.eye(n) + np.eye(n, k = -1) + np.eye(n,k=1))\n    return A-B\n\ndef buildE(n):\n    return np.ones(n)\n\ndef f(t,y,M,e):\n    return e - M@y\n\n\ndef mainSolver(deltaT, alpha,b,f = f,n_iter = 10,n_points=100):\n    t = 0\n    e = buildE(n_points)\n    M = buildM(b,n_points)\n    #First guess\n    y = np.copy(e)\n    resNorm = np.linalg.norm(M@y -e)\n\n    for i in range(n_iter):\n        y = RK2(f,y,t,deltaT,alpha,M = M,e = e)\n        t += deltaT\n        lastResNorm , resNorm = resNorm ,  np.linalg.norm(M@y - e)\n    return resNorm / lastResNorm\n```\n\n```{python}\nmainSolver(0.0001,0.5,0.5)\n```\n\nTo facilitate everything, we discretise the space with 100 interior points only, and with parameter $b = 0.5$.\n\n\n\nThis is how the solution looks like with the discretisation\n```{python}\n#| fig-cap: Discretised solution vs analytical solution\n\nb = 0.5\nn = 100\n\nM = buildM(b,n)\ne = buildE(n)\n\nx = np.linspace(0,1,n+2)\nx2 = np.linspace(0,1,n)\n\nanalyticSol = x - (np.exp(-(1-x)/b)-np.exp(-1/b))/(1-np.exp(-1/b))\nu = np.linalg.solve(M,e)\n\nplt.plot(x,analyticSol,label = 'Analytical solution')\nplt.plot(x2,u,label = 'Discretised solution')\nplt.legend()\n```\n\nHow would changing the parameters affect the residuals ratio after 10 iterations?\n\n\n```{python}\n#| fig-cap: Impact of the choice of time step with the residual ratios. \n\ndeltaTGrid = np.linspace(0.00001,0.0001,100)\n\nratio = np.zeros(100)\ni = 0\nfor deltaT in deltaTGrid:\n    ratio[i] = mainSolver(deltaT,0.6,0.5)\n    i+=1\n\nplt.plot(deltaTGrid,ratio)\nplt.xlabel('Delta T')\nplt.ylabel('Ratio')\n\n```\n\nHow would changing the RK parameter change the residual ratio after 10 iterations? Here we take the optimal delta T we found earlier.\n\n```{python}\n#fig-cap: Changing alpha does not do much...\nalphaGrid = np.linspace(0.01,0.99,100)\n\nratio = np.zeros(100)\ni = 0\nfor alpha in alphaGrid:\n    ratio[i] = mainSolver(0.00007,alpha,0.5)\n    i+=1\n\nplt.plot(alphaGrid,ratio)\nplt.xlabel('alpha')\nplt.ylabel('Ratio')\n```\n\n\n\nPendulum test\n```{python}\n#| output: false\ndef f(t,y):\n    g = 9.81\n    l = 1\n    f1 = y[1]\n    f2 = -g/l* np.sin(y[0])\n    return np.array([f1,f2])\n\n\n\n#Pendulum\ndeltaT = 0.01\nt_min = 0\nn = 1000\nt = t_min\ntArray = np.zeros(n+1)\ntArray[0] = t\ny = np.array([np.pi/2,0])\nyArray = np.zeros((n+1,2))\nyArray[0] = y\nfor i in range(n):\n    y = RK2(f,y,t,deltaT,0.9)\n    t+=deltaT\n    tArray[i+1] = t\n    yArray[i+1] = y\n\n\nplt.plot(tArray,yArray[:,0])\n```"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"Part1.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","bibliography":["references.bib"],"theme":"cosmo","title":"Testing ground for bachelor thesis","author":"Mélanie Fournier","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","number-sections":true,"include-in-header":{"text":"\\usepackage{amsmath}\n\\usepackage{easy-todo}\n\\usepackage{amsthm}\n"},"output-file":"Part1.pdf"},"language":{},"metadata":{"block-headings":true,"bibliography":["references.bib"],"documentclass":"article","title":"Testing ground for bachelor thesis","author":"Mélanie Fournier","jupyter":"python3","geometry":["top=30mm","left=20mm"],"fontsize":"14"},"extensions":{"book":{}}}}}